# ì½”ë“œ í‘œì¤€ ê°€ì´ë“œ v1.0.0 ğŸ“

> **Girls Band Tabi í”„ë¡œì íŠ¸ë¥¼ ìœ„í•œ ì¢…í•©ì ì¸ ì½”ë”© í‘œì¤€ ê°€ì´ë“œ**

## ë¬¸ì„œ ì •ë³´

- **ë²„ì „**: v1.0.0
- **ìµœì‹  ì—…ë°ì´íŠ¸**: 2025ë…„ 11ì›” 13ì¼  
- **ìƒíƒœ**: âœ… ìµœì‹ 
- **ì ìš© ë²”ìœ„ / Scope**: ì „ì²´ ë°±ì—”ë“œ ì½”ë“œë² ì´ìŠ¤ (Kotlin + Spring Boot 3.x)
- **ì—…ë°ì´íŠ¸ ì£¼ê¸° / Update Cycle**: ë¶„ê¸°ë³„ ê²€í†  ë° í•„ìš”ì‹œ ì—…ë°ì´íŠ¸
- **ìŠ¹ì¸ / Approved by**: ê°œë°œíŒ€ / Development Team

## 1. ì½”ë“œ ìŠ¤íƒ€ì¼ ë° í¬ë§·íŒ… í‘œì¤€ / Code Style & Formatting Standards

### 1.1 ê¸°ë³¸ ì›ì¹™ / Basic Principles

**EN**: We follow Google Kotlin Style Guide with specific adaptations for Spring Boot projects.  
**KO**: Google Kotlin Style Guideë¥¼ ê¸°ë°˜ìœ¼ë¡œ Spring Boot í”„ë¡œì íŠ¸ì— íŠ¹í™”ëœ ì ì‘ì„ ì ìš©í•©ë‹ˆë‹¤.

### 1.2 ë¼ì¸ ê¸¸ì´ / Line Length

```kotlin
// EN: Maximum 100 characters per line following Google Style Guide
// KO: Google ìŠ¤íƒ€ì¼ ê°€ì´ë“œì— ë”°ë¼ ë¼ì¸ë‹¹ ìµœëŒ€ 100ì
private fun createUserWithCompleteProfile(username: String, email: String, displayName: String)
```

### 1.3 ë“¤ì—¬ì“°ê¸° / Indentation

```kotlin
/**
 * EN: Use 4 spaces for indentation, no tabs
 * KO: ë“¤ì—¬ì“°ê¸°ëŠ” 4ê°œì˜ ìŠ¤í˜ì´ìŠ¤ ì‚¬ìš©, íƒ­ ì‚¬ìš© ê¸ˆì§€
 */
class UserService(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
    private val auditLogService: AuditLogService
) {
    fun createUser(request: CreateUserRequest): UserDto {
        return userRepository.save(
            UserEntity(
                username = request.username,
                email = request.email,
                encodedPassword = passwordEncoder.encode(request.password)
            )
        ).toDto()
    }
}
```

### 1.4 Import êµ¬ì„± / Import Organization

```kotlin
// EN: Import order following Google Style Guide
// KO: Google ìŠ¤íƒ€ì¼ ê°€ì´ë“œì— ë”°ë¥¸ Import ìˆœì„œ

// 1. Standard library imports
import java.util.*
import java.time.LocalDateTime

// 2. Third-party library imports
import org.springframework.stereotype.Service
import org.springframework.cache.annotation.Cacheable

// 3. Project-specific imports
import org.pyrimidines.girlsbandtabi.dto.user.UserDto
import org.pyrimidines.girlsbandtabi.persistence.entity.UserEntity
```

## 2. ëª…ëª… ê·œì¹™ / Naming Conventions

### 2.1 í´ë˜ìŠ¤ ëª…ëª… / Class Naming

```kotlin
/**
 * EN: Use PascalCase for classes, interfaces, and enums
 * KO: í´ë˜ìŠ¤, ì¸í„°í˜ì´ìŠ¤, ì—´ê±°í˜•ì—ëŠ” PascalCase ì‚¬ìš©
 */

// Controllers
class ProjectController // âœ… Good
class projectController // âŒ Bad

// Services  
class UserManagementService // âœ… Good
class userService // âŒ Bad

// DTOs
class CreateProjectRequest // âœ… Good
class projectCreateDto // âŒ Bad

// Entities
class ProjectEntity // âœ… Good
class project_entity // âŒ Bad

// Repositories
interface ProjectRepository // âœ… Good
interface projectRepo // âŒ Bad
```

### 2.2 ë©”ì†Œë“œ ë° í•¨ìˆ˜ ëª…ëª… / Method & Function Naming

```kotlin
/**
 * EN: Use camelCase for functions and methods, start with verbs
 * KO: í•¨ìˆ˜ì™€ ë©”ì†Œë“œëŠ” camelCase ì‚¬ìš©, ë™ì‚¬ë¡œ ì‹œì‘
 */

class UserService {
    // âœ… Good - Clear action verbs
    fun createUser(request: CreateUserRequest): UserDto
    fun updateUserProfile(userId: String, request: UpdateProfileRequest): UserDto
    fun deleteUserAccount(userId: String)
    fun findUserByEmail(email: String): UserDto?
    fun validateUserCredentials(username: String, password: String): Boolean
    
    // âŒ Bad - Unclear or incorrect naming
    fun user(request: CreateUserRequest): UserDto  // Missing verb
    fun UpdateUser(userId: String): UserDto         // Wrong case
    fun get_user(userId: String): UserDto           // Snake case
}
```

### 2.3 ë³€ìˆ˜ ëª…ëª… / Variable Naming

```kotlin
/**
 * EN: Use descriptive camelCase names, avoid abbreviations
 * KO: ì„¤ëª…ì ì¸ camelCase ì´ë¦„ ì‚¬ìš©, ì•½ì–´ í”¼í•˜ê¸°
 */

// âœ… Good - Descriptive and clear
val userRepository: UserRepository
val currentUserSession: UserSession
val projectCreationDate: LocalDateTime
val isUserAccountActive: Boolean
val maxRetryAttempts: Int = 3

// âŒ Bad - Unclear abbreviations
val usrRepo: UserRepository
val sess: UserSession  
val dt: LocalDateTime
val active: Boolean
val max: Int = 3
```

### 2.4 ìƒìˆ˜ ëª…ëª… / Constants Naming

```kotlin
/**
 * EN: Use SCREAMING_SNAKE_CASE for constants
 * KO: ìƒìˆ˜ëŠ” SCREAMING_SNAKE_CASE ì‚¬ìš©
 */

object ApplicationConstants {
    const val DEFAULT_PAGE_SIZE: Int = 20
    const val MAX_FILE_UPLOAD_SIZE: Long = 10_485_760L // 10MB
    const val JWT_TOKEN_EXPIRY_HOURS: Long = 24
    const val CACHE_TTL_MINUTES: Long = 30
    const val API_VERSION: String = "v1"
}
```

### 2.5 íŒ¨í‚¤ì§€ ëª…ëª… / Package Naming

```kotlin
/**
 * EN: Use lowercase separated by dots, follow reverse domain convention
 * KO: ì ìœ¼ë¡œ êµ¬ë¶„ëœ ì†Œë¬¸ì ì‚¬ìš©, ì—­ ë„ë©”ì¸ ê·œì•½ ë”°ë¥´ê¸°
 */

// âœ… Good - Clear hierarchy and purpose
package org.pyrimidines.girlsbandtabi.gateway.rest
package org.pyrimidines.girlsbandtabi.service.user
package org.pyrimidines.girlsbandtabi.persistence.entity
package org.pyrimidines.girlsbandtabi.dto.project
package org.pyrimidines.girlsbandtabi.config.security

// âŒ Bad - Mixed case or unclear hierarchy  
package org.pyrimidines.girlsbandtabi.Gateway.Rest
package org.pyrimidines.girlsbandtabi.serviceUser
package org.pyrimidines.girlsbandtabi.dtos
```

## 3. ë¬¸ì„œí™” í‘œì¤€ / Documentation Standards

### 3.1 KDoc ì´ì¤‘ ì–¸ì–´ ì£¼ì„ / Bilingual KDoc Comments

```kotlin
/**
 * EN: Creates a new user account with the provided profile information.
 * KO: ì œê³µëœ í”„ë¡œí•„ ì •ë³´ë¡œ ìƒˆë¡œìš´ ì‚¬ìš©ì ê³„ì •ì„ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * @param request The user creation request containing username, email and password
 *                ì‚¬ìš©ìëª…, ì´ë©”ì¼, ë¹„ë°€ë²ˆí˜¸ë¥¼ í¬í•¨í•œ ì‚¬ìš©ì ìƒì„± ìš”ì²­
 * @return UserDto containing the created user information
 *         ìƒì„±ëœ ì‚¬ìš©ì ì •ë³´ë¥¼ í¬í•¨í•˜ëŠ” UserDto
 * @throws IllegalArgumentException if username or email already exists
 *                                  ì‚¬ìš©ìëª…ì´ë‚˜ ì´ë©”ì¼ì´ ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ê²½ìš°
 * @throws ValidationException if request validation fails
 *                            ìš”ì²­ ê²€ì¦ì´ ì‹¤íŒ¨í•œ ê²½ìš°
 * @since 1.0.0
 */
@Transactional
fun createUser(request: CreateUserRequest): UserDto {
    // EN: Validate that username is not already taken
    // KO: ì‚¬ìš©ìëª…ì´ ì´ë¯¸ ì‚¬ìš© ì¤‘ì´ ì•„ë‹Œì§€ ê²€ì¦
    if (userRepository.existsByUsername(request.username)) {
        throw IllegalArgumentException("Username already exists")
    }
    
    // Implementation...
}
```

### 3.2 ì¸ë¼ì¸ ì£¼ì„ í‘œì¤€ / Inline Comments Standards

```kotlin
class ProjectService {
    
    @Cacheable("projects")
    fun getProject(projectId: String): ProjectDto {
        // EN: Check cache first before database query to improve performance
        // KO: ì„±ëŠ¥ í–¥ìƒì„ ìœ„í•´ ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ì „ì— ìºì‹œë¥¼ ë¨¼ì € í™•ì¸
        
        // EN: Use findByIdentifierOrThrow for consistent error handling
        // KO: ì¼ê´€ëœ ì˜¤ë¥˜ ì²˜ë¦¬ë¥¼ ìœ„í•´ findByIdentifierOrThrow ì‚¬ìš©
        val project = projectRepository.findByIdentifierOrThrow(projectId)
        
        return project.toDto()
    }
}
```

### 3.3 README ë° ëª¨ë“ˆ ë¬¸ì„œí™” / README & Module Documentation

```markdown
# ëª¨ë“ˆëª… / Module Name

## ê°œìš” / Overview
**EN**: Brief description of module purpose  
**KO**: ëª¨ë“ˆì˜ ëª©ì ì— ëŒ€í•œ ê°„ë‹¨í•œ ì„¤ëª…

## ì£¼ìš” ê¸°ëŠ¥ / Key Features
- **EN**: Feature 1 description / **KO**: ê¸°ëŠ¥ 1 ì„¤ëª…
- **EN**: Feature 2 description / **KO**: ê¸°ëŠ¥ 2 ì„¤ëª…

## API ì—”ë“œí¬ì¸íŠ¸ / API Endpoints
| Method | Path | Description (EN/KO) |
|--------|------|---------------------|
| GET    | /api/v1/projects | List projects / í”„ë¡œì íŠ¸ ëª©ë¡ ì¡°íšŒ |
| POST   | /api/v1/projects | Create project / í”„ë¡œì íŠ¸ ìƒì„± |
```

## 4. SOLID ì›ì¹™ êµ¬í˜„ ë° ë””ìì¸ íŒ¨í„´ / SOLID Principles & Design Patterns

### 4.1 Single Responsibility Principle (SRP)

```kotlin
/**
 * EN: Each class should have one reason to change
 * KO: ê° í´ë˜ìŠ¤ëŠ” ë³€ê²½ë˜ì–´ì•¼ í•  í•˜ë‚˜ì˜ ì´ìœ ë§Œ ê°€ì ¸ì•¼ í•©ë‹ˆë‹¤
 */

// âœ… Good - Single responsibility: user authentication
class UserAuthenticationService(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder
) {
    fun authenticate(username: String, password: String): AuthenticationResult {
        val user = userRepository.findByUsername(username)
            ?: return AuthenticationResult.failed("User not found")
            
        if (!passwordEncoder.matches(password, user.encodedPassword)) {
            return AuthenticationResult.failed("Invalid password")
        }
        
        return AuthenticationResult.success(user)
    }
}

// âœ… Good - Single responsibility: user profile management  
class UserProfileService(
    private val userRepository: UserRepository,
    private val auditLogService: AuditLogService
) {
    fun updateProfile(userId: String, request: UpdateProfileRequest): UserDto {
        val user = userRepository.findByIdOrNull(userId)
            ?: throw UserNotFoundException("User not found: $userId")
            
        user.updateProfile(request)
        auditLogService.logProfileUpdate(userId, request)
        
        return userRepository.save(user).toDto()
    }
}
```

### 4.2 Open/Closed Principle (OCP)

```kotlin
/**
 * EN: Classes should be open for extension but closed for modification
 * KO: í´ë˜ìŠ¤ëŠ” í™•ì¥ì—ëŠ” ì—´ë ¤ìˆê³  ìˆ˜ì •ì—ëŠ” ë‹«í˜€ìˆì–´ì•¼ í•©ë‹ˆë‹¤
 */

// âœ… Good - Strategy pattern for extensibility
interface NotificationStrategy {
    fun send(message: String, recipient: String): NotificationResult
}

class EmailNotificationStrategy : NotificationStrategy {
    override fun send(message: String, recipient: String): NotificationResult {
        // Email sending implementation
        return NotificationResult.success("Email sent to $recipient")
    }
}

class SmsNotificationStrategy : NotificationStrategy {
    override fun send(message: String, recipient: String): NotificationResult {
        // SMS sending implementation  
        return NotificationResult.success("SMS sent to $recipient")
    }
}

class NotificationService(
    private val strategies: Map<NotificationType, NotificationStrategy>
) {
    fun sendNotification(type: NotificationType, message: String, recipient: String) {
        val strategy = strategies[type] 
            ?: throw IllegalArgumentException("Unsupported notification type: $type")
        strategy.send(message, recipient)
    }
}
```

### 4.3 Liskov Substitution Principle (LSP)

```kotlin
/**
 * EN: Subtypes must be substitutable for their base types
 * KO: ì„œë¸Œíƒ€ì…ì€ ê¸°ë³¸ íƒ€ì…ìœ¼ë¡œ ëŒ€ì²´ ê°€ëŠ¥í•´ì•¼ í•©ë‹ˆë‹¤
 */

// âœ… Good - Proper inheritance that maintains contract
abstract class MediaProcessor {
    /**
     * EN: Process media file and return processing result
     * KO: ë¯¸ë””ì–´ íŒŒì¼ì„ ì²˜ë¦¬í•˜ê³  ì²˜ë¦¬ ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤
     */
    abstract fun processMedia(inputPath: String): ProcessingResult
    
    protected fun validateInputFile(path: String) {
        if (!File(path).exists()) {
            throw IllegalArgumentException("Input file does not exist: $path")
        }
    }
}

class ImageProcessor : MediaProcessor() {
    override fun processMedia(inputPath: String): ProcessingResult {
        validateInputFile(inputPath)
        // Image-specific processing that maintains the contract
        return ProcessingResult.success("Image processed successfully")
    }
}

class VideoProcessor : MediaProcessor() {
    override fun processMedia(inputPath: String): ProcessingResult {
        validateInputFile(inputPath)
        // Video-specific processing that maintains the contract
        return ProcessingResult.success("Video processed successfully")
    }
}
```

### 4.4 Interface Segregation Principle (ISP)

```kotlin
/**
 * EN: Clients should not depend on interfaces they don't use
 * KO: í´ë¼ì´ì–¸íŠ¸ëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ì¸í„°í˜ì´ìŠ¤ì— ì˜ì¡´í•˜ì§€ ì•Šì•„ì•¼ í•©ë‹ˆë‹¤
 */

// âœ… Good - Segregated interfaces
interface UserReader {
    fun findById(id: String): UserDto?
    fun findByEmail(email: String): UserDto?
}

interface UserWriter {
    fun createUser(request: CreateUserRequest): UserDto
    fun updateUser(id: String, request: UpdateUserRequest): UserDto
    fun deleteUser(id: String)
}

interface UserValidator {
    fun validateCreateRequest(request: CreateUserRequest): ValidationResult
    fun validateUpdateRequest(request: UpdateUserRequest): ValidationResult
}

// Implementation can choose which interfaces to implement
class UserService(
    private val userRepository: UserRepository
) : UserReader, UserWriter {
    // Only implement needed methods
}

class UserValidationService : UserValidator {
    // Only implement validation methods
}
```

### 4.5 Dependency Inversion Principle (DIP)

```kotlin
/**
 * EN: High-level modules should not depend on low-level modules
 * KO: ê³ ìˆ˜ì¤€ ëª¨ë“ˆì€ ì €ìˆ˜ì¤€ ëª¨ë“ˆì— ì˜ì¡´í•˜ì§€ ì•Šì•„ì•¼ í•©ë‹ˆë‹¤
 */

// âœ… Good - Dependency inversion with interfaces
interface FileStoragePort {
    fun store(file: ByteArray, filename: String): String
    fun retrieve(url: String): ByteArray
    fun delete(url: String)
}

interface EventPublisherPort {
    fun publishUserCreated(userId: String, userEmail: String)
    fun publishUserUpdated(userId: String, changes: Map<String, Any>)
}

@Service
class UserService(
    private val userRepository: UserRepository,
    private val fileStorage: FileStoragePort,  // Interface dependency
    private val eventPublisher: EventPublisherPort  // Interface dependency
) {
    fun createUserWithAvatar(request: CreateUserWithAvatarRequest): UserDto {
        val user = UserEntity.create(request)
        val savedUser = userRepository.save(user)
        
        // EN: Upload avatar through abstraction
        // KO: ì¶”ìƒí™”ë¥¼ í†µí•œ ì•„ë°”íƒ€ ì—…ë¡œë“œ
        val avatarUrl = fileStorage.store(request.avatarData, "avatar_${savedUser.id}")
        savedUser.avatarUrl = avatarUrl
        
        // EN: Publish event through abstraction
        // KO: ì¶”ìƒí™”ë¥¼ í†µí•œ ì´ë²¤íŠ¸ ë°œí–‰
        eventPublisher.publishUserCreated(savedUser.id.toString(), savedUser.email)
        
        return savedUser.toDto()
    }
}

// Infrastructure implementations
@Component
class CloudflareR2FileStorage : FileStoragePort {
    override fun store(file: ByteArray, filename: String): String {
        // R2 implementation
    }
}

@Component  
class SpringEventPublisher : EventPublisherPort {
    override fun publishUserCreated(userId: String, userEmail: String) {
        // Spring Application Events implementation
    }
}
```

## 5. í…ŒìŠ¤íŠ¸ í‘œì¤€ / Testing Standards

### 5.1 í…ŒìŠ¤íŠ¸ ëª…ëª… ê·œì¹™ / Test Naming Conventions

```kotlin
/**
 * EN: Use descriptive test names that explain what is being tested
 * KO: í…ŒìŠ¤íŠ¸í•˜ëŠ” ë‚´ìš©ì„ ì„¤ëª…í•˜ëŠ” ëª…ì‹œì ì¸ í…ŒìŠ¤íŠ¸ ì´ë¦„ ì‚¬ìš©
 */

@Test
fun `createUser should return UserDto when request is valid`() {
    // Arrange, Act, Assert
}

@Test  
fun `createUser should throw IllegalArgumentException when username already exists`() {
    // Test implementation
}

@Test
fun `getProjectsByUser should return empty list when user has no projects`() {
    // Test implementation
}

@Test
fun `updateProject should update cache when project is successfully modified`() {
    // Test implementation
}
```

### 5.2 ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ êµ¬ì¡° / Unit Test Structure

```kotlin
/**
 * EN: Follow Arrange-Act-Assert pattern for test structure
 * KO: í…ŒìŠ¤íŠ¸ êµ¬ì¡°ì— Arrange-Act-Assert íŒ¨í„´ ë”°ë¥´ê¸°
 */

@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    
    @Mock
    private lateinit var userRepository: UserRepository
    
    @Mock  
    private lateinit var passwordEncoder: PasswordEncoder
    
    @InjectMocks
    private lateinit var userService: UserService
    
    @Test
    fun `createUser should save user and return dto when request is valid`() {
        // Arrange - EN: Set up test data and mock behavior
        //         - KO: í…ŒìŠ¤íŠ¸ ë°ì´í„°ì™€ Mock ë™ì‘ ì„¤ì •
        val request = CreateUserRequest(
            username = "testuser",
            email = "test@example.com", 
            password = "password123"
        )
        val encodedPassword = "encoded_password"
        val savedUser = UserEntity(
            id = UUID.randomUUID(),
            username = request.username,
            email = request.email,
            encodedPassword = encodedPassword
        )
        
        whenever(userRepository.existsByUsername(request.username)).thenReturn(false)
        whenever(passwordEncoder.encode(request.password)).thenReturn(encodedPassword)
        whenever(userRepository.save(any<UserEntity>())).thenReturn(savedUser)
        
        // Act - EN: Execute the method under test
        //     - KO: í…ŒìŠ¤íŠ¸ ëŒ€ìƒ ë©”ì†Œë“œ ì‹¤í–‰
        val result = userService.createUser(request)
        
        // Assert - EN: Verify the results
        //        - KO: ê²°ê³¼ ê²€ì¦
        assertThat(result).isNotNull()
        assertThat(result.username).isEqualTo(request.username)
        assertThat(result.email).isEqualTo(request.email)
        
        verify(userRepository).save(any<UserEntity>())
        verify(passwordEncoder).encode(request.password)
    }
    
    @Test
    fun `createUser should throw IllegalArgumentException when username exists`() {
        // Arrange
        val request = CreateUserRequest("existinguser", "test@example.com", "password")
        whenever(userRepository.existsByUsername(request.username)).thenReturn(true)
        
        // Act & Assert
        assertThatThrownBy { userService.createUser(request) }
            .isInstanceOf(IllegalArgumentException::class.java)
            .hasMessage("Username already exists")
            
        verify(userRepository, never()).save(any<UserEntity>())
    }
}
```

### 5.3 í†µí•© í…ŒìŠ¤íŠ¸ / Integration Tests

```kotlin
/**
 * EN: Integration tests for testing component interactions
 * KO: ì»´í¬ë„ŒíŠ¸ ìƒí˜¸ì‘ìš©ì„ í…ŒìŠ¤íŠ¸í•˜ëŠ” í†µí•© í…ŒìŠ¤íŠ¸
 */

@SpringBootTest
@ActiveProfiles("test")
@Transactional
class UserServiceIntegrationTest {
    
    @Autowired
    private lateinit var userService: UserService
    
    @Autowired
    private lateinit var userRepository: UserRepository
    
    @Test
    fun `should create user and persist to database`() {
        // Arrange
        val request = CreateUserRequest(
            username = "integrationtest",
            email = "integration@test.com",
            password = "testpassword"
        )
        
        // Act
        val result = userService.createUser(request)
        
        // Assert
        assertThat(result.id).isNotNull()
        
        val savedUser = userRepository.findById(UUID.fromString(result.id))
        assertThat(savedUser).isPresent
        assertThat(savedUser.get().username).isEqualTo(request.username)
    }
}
```

### 5.4 í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ ëª©í‘œ / Test Coverage Goals

```kotlin
/**
 * EN: Minimum test coverage requirements by component type
 * KO: ì»´í¬ë„ŒíŠ¸ ìœ í˜•ë³„ ìµœì†Œ í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ ìš”êµ¬ì‚¬í•­
 */

// Service Layer: 90%+ coverage
@Service
class UserService {
    // All public methods should have comprehensive tests
    // EN: Critical business logic must be fully tested
    // KO: ì¤‘ìš”í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì€ ì™„ì „íˆ í…ŒìŠ¤íŠ¸ë˜ì–´ì•¼ í•¨
}

// Controller Layer: 80%+ coverage  
@RestController
class UserController {
    // Test all endpoints with various scenarios
    // EN: Include positive, negative, and edge cases
    // KO: ê¸ì •ì , ë¶€ì •ì , ê²½ê³„ê°’ ì¼€ì´ìŠ¤ í¬í•¨
}

// Repository Layer: 85%+ coverage
interface UserRepository : JpaRepository<UserEntity, UUID> {
    // Test custom query methods thoroughly
    // EN: Verify complex queries and relationships
    // KO: ë³µì¡í•œ ì¿¼ë¦¬ì™€ ê´€ê³„ ê²€ì¦
}
```

## 6. ì—ëŸ¬ í•¸ë“¤ë§ íŒ¨í„´ ë° ì˜ˆì™¸ ì„¤ê³„ / Error Handling Patterns & Exception Design

### 6.1 ì˜ˆì™¸ ê³„ì¸µêµ¬ì¡° / Exception Hierarchy

```kotlin
/**
 * EN: Define clear exception hierarchy for consistent error handling
 * KO: ì¼ê´€ëœ ì˜¤ë¥˜ ì²˜ë¦¬ë¥¼ ìœ„í•œ ëª…í™•í•œ ì˜ˆì™¸ ê³„ì¸µêµ¬ì¡° ì •ì˜
 */

// Base application exception
sealed class ApplicationException(
    message: String,
    cause: Throwable? = null
) : RuntimeException(message, cause)

// Business logic exceptions
class BusinessLogicException(
    message: String,
    val errorCode: String,
    cause: Throwable? = null
) : ApplicationException(message, cause)

// Resource not found exceptions
class ResourceNotFoundException(
    message: String,
    val resourceType: String,
    val resourceId: String,
    cause: Throwable? = null
) : ApplicationException(message, cause)

// Validation exceptions
class ValidationException(
    message: String,
    val violations: List<String>,
    cause: Throwable? = null
) : ApplicationException(message, cause)

// Security exceptions
class SecurityException(
    message: String,
    val securityEvent: String,
    cause: Throwable? = null
) : ApplicationException(message, cause)
```

### 6.2 ì˜ˆì™¸ ì‚¬ìš© ì˜ˆì‹œ / Exception Usage Examples

```kotlin
/**
 * EN: Proper exception throwing and handling examples
 * KO: ì ì ˆí•œ ì˜ˆì™¸ ë°œìƒ ë° ì²˜ë¦¬ ì˜ˆì‹œ
 */

@Service
class ProjectService(private val projectRepository: ProjectRepository) {
    
    fun getProject(projectId: String): ProjectDto {
        // EN: Use specific exceptions with context information
        // KO: ì»¨í…ìŠ¤íŠ¸ ì •ë³´ì™€ í•¨ê»˜ íŠ¹ì • ì˜ˆì™¸ ì‚¬ìš©
        val project = projectRepository.findByIdOrNull(projectId)
            ?: throw ResourceNotFoundException(
                message = "Project not found with ID: $projectId",
                resourceType = "Project",
                resourceId = projectId
            )
        
        return project.toDto()
    }
    
    fun createProject(request: CreateProjectRequest): ProjectDto {
        // EN: Validate input and throw meaningful exceptions
        // KO: ì…ë ¥ ê²€ì¦ ë° ì˜ë¯¸ìˆëŠ” ì˜ˆì™¸ ë°œìƒ
        if (projectRepository.existsBySlug(request.slug)) {
            throw BusinessLogicException(
                message = "Project with slug '${request.slug}' already exists",
                errorCode = "PROJECT_SLUG_DUPLICATE"
            )
        }
        
        val violations = validateProjectRequest(request)
        if (violations.isNotEmpty()) {
            throw ValidationException(
                message = "Invalid project creation request",
                violations = violations
            )
        }
        
        return try {
            val entity = ProjectEntity.fromRequest(request)
            projectRepository.save(entity).toDto()
        } catch (e: DataAccessException) {
            // EN: Wrap infrastructure exceptions with domain context
            // KO: ì¸í”„ë¼ ì˜ˆì™¸ë¥¼ ë„ë©”ì¸ ì»¨í…ìŠ¤íŠ¸ë¡œ ë˜í•‘
            throw BusinessLogicException(
                message = "Failed to create project due to data access error",
                errorCode = "PROJECT_CREATION_FAILED",
                cause = e
            )
        }
    }
}
```

### 6.3 ì „ì—­ ì˜ˆì™¸ ì²˜ë¦¬ / Global Exception Handling

```kotlin
/**
 * EN: Centralized exception handling with consistent error responses
 * KO: ì¼ê´€ëœ ì˜¤ë¥˜ ì‘ë‹µì„ ìœ„í•œ ì¤‘ì•™í™”ëœ ì˜ˆì™¸ ì²˜ë¦¬
 */

@RestControllerAdvice
class GlobalExceptionHandler {
    
    companion object {
        private val logger = LoggerFactory.getLogger(GlobalExceptionHandler::class.java)
    }
    
    @ExceptionHandler(ResourceNotFoundException::class)
    fun handleResourceNotFound(ex: ResourceNotFoundException): ResponseEntity<ErrorResponse> {
        // EN: Log error with correlation ID for tracing
        // KO: ì¶”ì ì„ ìœ„í•œ ìƒê´€ê´€ê³„ IDì™€ í•¨ê»˜ ì˜¤ë¥˜ ë¡œê¹…
        logger.warn("Resource not found: ${ex.message}", ex)
        
        val errorResponse = ErrorResponse(
            status = HttpStatus.NOT_FOUND.value(),
            error = "RESOURCE_NOT_FOUND",
            message = ex.message ?: "Resource not found",
            timestamp = Instant.now(),
            path = getCurrentRequestPath(),
            details = mapOf(
                "resourceType" to ex.resourceType,
                "resourceId" to ex.resourceId
            )
        )
        
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse)
    }
    
    @ExceptionHandler(ValidationException::class) 
    fun handleValidation(ex: ValidationException): ResponseEntity<ErrorResponse> {
        logger.warn("Validation failed: ${ex.message}", ex)
        
        val errorResponse = ErrorResponse(
            status = HttpStatus.BAD_REQUEST.value(),
            error = "VALIDATION_FAILED",
            message = ex.message ?: "Validation failed",
            timestamp = Instant.now(),
            path = getCurrentRequestPath(),
            details = mapOf("violations" to ex.violations)
        )
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse)
    }
    
    @ExceptionHandler(BusinessLogicException::class)
    fun handleBusinessLogic(ex: BusinessLogicException): ResponseEntity<ErrorResponse> {
        logger.error("Business logic error: ${ex.message}", ex)
        
        val errorResponse = ErrorResponse(
            status = HttpStatus.CONFLICT.value(),
            error = ex.errorCode,
            message = ex.message ?: "Business logic error",
            timestamp = Instant.now(),
            path = getCurrentRequestPath()
        )
        
        return ResponseEntity.status(HttpStatus.CONFLICT).body(errorResponse)
    }
}

data class ErrorResponse(
    val status: Int,
    val error: String,
    val message: String,
    val timestamp: Instant,
    val path: String,
    val details: Map<String, Any> = emptyMap()
)
```

## 7. ë¡œê¹… í‘œì¤€ ë° êµ¬ì¡°í™”ëœ ë¡œê¹… / Logging Standards & Structured Logging

### 7.1 ë¡œê·¸ ë ˆë²¨ ì‚¬ìš© ê°€ì´ë“œ / Log Level Usage Guide

```kotlin
/**
 * EN: Proper usage of different log levels
 * KO: ë‹¤ì–‘í•œ ë¡œê·¸ ë ˆë²¨ì˜ ì ì ˆí•œ ì‚¬ìš©ë²•
 */

@Service
class UserService(
    private val userRepository: UserRepository,
    private val auditLogService: AuditLogService
) {
    companion object {
        private val logger = LoggerFactory.getLogger(UserService::class.java)
    }
    
    fun createUser(request: CreateUserRequest): UserDto {
        // TRACE - EN: Detailed execution flow for debugging
        //       - KO: ë””ë²„ê¹…ì„ ìœ„í•œ ìƒì„¸í•œ ì‹¤í–‰ íë¦„
        logger.trace("Entering createUser with username: {}", request.username)
        
        // DEBUG - EN: Development and troubleshooting information
        //       - KO: ê°œë°œ ë° ë¬¸ì œ í•´ê²° ì •ë³´
        logger.debug("Validating user creation request for username: {}", request.username)
        
        // INFO - EN: Important business events and normal operations
        //      - KO: ì¤‘ìš”í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ì´ë²¤íŠ¸ ë° ì •ìƒ ìš´ì˜ ìƒí™©
        logger.info("Creating new user account: username={}, email={}", 
                   request.username, request.email)
        
        try {
            val user = UserEntity.fromRequest(request)
            val savedUser = userRepository.save(user)
            
            // EN: Log successful operations with key identifiers
            // KO: ì£¼ìš” ì‹ë³„ìì™€ í•¨ê»˜ ì„±ê³µì ì¸ ì‘ì—… ë¡œê¹…
            logger.info("User account created successfully: userId={}, username={}", 
                       savedUser.id, savedUser.username)
            
            return savedUser.toDto()
            
        } catch (e: DataIntegrityViolationException) {
            // WARN - EN: Expected errors that don't stop application flow
            //      - KO: ì• í”Œë¦¬ì¼€ì´ì…˜ íë¦„ì„ ì¤‘ë‹¨í•˜ì§€ ì•ŠëŠ” ì˜ˆìƒëœ ì˜¤ë¥˜
            logger.warn("User creation failed due to data constraint violation: username={}, error={}", 
                       request.username, e.message)
            throw BusinessLogicException("Username or email already exists", "USER_DUPLICATE")
            
        } catch (e: Exception) {
            // ERROR - EN: Unexpected errors that require investigation
            //       - KO: ì¡°ì‚¬ê°€ í•„ìš”í•œ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜
            logger.error("Unexpected error during user creation: username={}", 
                        request.username, e)
            throw BusinessLogicException("User creation failed", "USER_CREATION_ERROR", e)
        }
    }
}
```

### 7.2 êµ¬ì¡°í™”ëœ ë¡œê¹… / Structured Logging

```kotlin
/**
 * EN: Use structured logging with correlation IDs and context
 * KO: ìƒê´€ê´€ê³„ IDì™€ ì»¨í…ìŠ¤íŠ¸ë¥¼ í¬í•¨í•œ êµ¬ì¡°í™”ëœ ë¡œê¹…
 */

@Component
class StructuredLogger {
    
    private val logger = LoggerFactory.getLogger(StructuredLogger::class.java)
    
    fun logUserAction(
        userId: String,
        action: String,
        resource: String,
        result: String,
        correlationId: String = UUID.randomUUID().toString(),
        additionalData: Map<String, Any> = emptyMap()
    ) {
        // EN: Use MDC (Mapped Diagnostic Context) for correlation tracking
        // KO: ìƒê´€ê´€ê³„ ì¶”ì ì„ ìœ„í•œ MDC(Mapped Diagnostic Context) ì‚¬ìš©
        MDC.put("correlationId", correlationId)
        MDC.put("userId", userId)
        
        try {
            val logData = mapOf(
                "action" to action,
                "resource" to resource,
                "result" to result,
                "timestamp" to Instant.now(),
                "metadata" to additionalData
            )
            
            logger.info("User action: {}", objectMapper.writeValueAsString(logData))
            
        } finally {
            // EN: Always clean up MDC to prevent memory leaks
            // KO: ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€ë¥¼ ìœ„í•´ í•­ìƒ MDC ì •ë¦¬
            MDC.clear()
        }
    }
    
    fun logSecurityEvent(
        event: SecurityEvent,
        severity: SecuritySeverity,
        details: Map<String, Any> = emptyMap()
    ) {
        val securityLog = SecurityLogEntry(
            eventType = event.type,
            severity = severity,
            timestamp = Instant.now(),
            sourceIp = getCurrentRequestIp(),
            userAgent = getCurrentUserAgent(),
            details = details
        )
        
        when (severity) {
            SecuritySeverity.HIGH -> logger.error("Security event: {}", 
                                                 objectMapper.writeValueAsString(securityLog))
            SecuritySeverity.MEDIUM -> logger.warn("Security event: {}", 
                                                  objectMapper.writeValueAsString(securityLog))
            SecuritySeverity.LOW -> logger.info("Security event: {}", 
                                               objectMapper.writeValueAsString(securityLog))
        }
    }
}

data class SecurityLogEntry(
    val eventType: String,
    val severity: SecuritySeverity,
    val timestamp: Instant,
    val sourceIp: String?,
    val userAgent: String?,
    val details: Map<String, Any>
)

enum class SecuritySeverity { LOW, MEDIUM, HIGH }
```

### 7.3 ì„±ëŠ¥ ë¡œê¹… / Performance Logging

```kotlin
/**
 * EN: Log performance metrics for monitoring and optimization
 * KO: ëª¨ë‹ˆí„°ë§ ë° ìµœì í™”ë¥¼ ìœ„í•œ ì„±ëŠ¥ ë©”íŠ¸ë¦­ ë¡œê¹…
 */

@Component
class PerformanceLogger {
    
    private val logger = LoggerFactory.getLogger(PerformanceLogger::class.java)
    
    inline fun <T> logExecutionTime(
        operation: String,
        threshold: Duration = Duration.ofMillis(1000),
        block: () -> T
    ): T {
        val startTime = Instant.now()
        return try {
            block()
        } finally {
            val duration = Duration.between(startTime, Instant.now())
            
            if (duration > threshold) {
                // EN: Log slow operations for performance analysis
                // KO: ì„±ëŠ¥ ë¶„ì„ì„ ìœ„í•œ ëŠë¦° ì‘ì—… ë¡œê¹…
                logger.warn("Slow operation detected: operation={}, duration={}ms", 
                           operation, duration.toMillis())
            } else {
                logger.debug("Operation completed: operation={}, duration={}ms", 
                            operation, duration.toMillis())
            }
        }
    }
}

// Usage example
@Service
class ProjectService(private val performanceLogger: PerformanceLogger) {
    
    fun getProjectsWithMetrics(userId: String): List<ProjectDto> {
        return performanceLogger.logExecutionTime("getProjectsByUser") {
            // EN: Actual business logic here
            // KO: ì‹¤ì œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì—¬ê¸°ì— 
            projectRepository.findByUserId(userId).map { it.toDto() }
        }
    }
}
```

## 8. ì½”ë“œ ë¦¬ë·° ê°€ì´ë“œë¼ì¸ ë° ì²´í¬ë¦¬ìŠ¤íŠ¸ / Code Review Guidelines & Checklist

### 8.1 ì½”ë“œ ë¦¬ë·° í”„ë¡œì„¸ìŠ¤ / Code Review Process

```markdown
## ì½”ë“œ ë¦¬ë·° ì²´í¬ë¦¬ìŠ¤íŠ¸ / Code Review Checklist

### ê¸°ëŠ¥ì„± / Functionality
- [ ] **EN**: Code correctly implements the required functionality  
      **KO**: ì½”ë“œê°€ ìš”êµ¬ëœ ê¸°ëŠ¥ì„ ì˜¬ë°”ë¥´ê²Œ êµ¬í˜„í–ˆëŠ”ê°€
- [ ] **EN**: Edge cases are properly handled  
      **KO**: ê²½ê³„ ì¼€ì´ìŠ¤ê°€ ì ì ˆíˆ ì²˜ë¦¬ë˜ì—ˆëŠ”ê°€
- [ ] **EN**: Error conditions are handled gracefully  
      **KO**: ì˜¤ë¥˜ ìƒí™©ì´ ìš°ì•„í•˜ê²Œ ì²˜ë¦¬ë˜ì—ˆëŠ”ê°€

### ì½”ë“œ í’ˆì§ˆ / Code Quality  
- [ ] **EN**: Code follows SOLID principles  
      **KO**: SOLID ì›ì¹™ì„ ë”°ë¥´ëŠ”ê°€
- [ ] **EN**: Functions are single-purpose and well-named  
      **KO**: í•¨ìˆ˜ê°€ ë‹¨ì¼ ëª©ì ì´ê³  ì˜ ëª…ëª…ë˜ì—ˆëŠ”ê°€
- [ ] **EN**: Code is readable and self-documenting  
      **KO**: ì½”ë“œê°€ ì½ê¸° ì‰½ê³  ìì²´ ë¬¸ì„œí™”ë˜ì–´ ìˆëŠ”ê°€
- [ ] **EN**: No code duplication (DRY principle)  
      **KO**: ì½”ë“œ ì¤‘ë³µì´ ì—†ëŠ”ê°€ (DRY ì›ì¹™)

### ë³´ì•ˆ / Security
- [ ] **EN**: Input validation is performed  
      **KO**: ì…ë ¥ ê²€ì¦ì´ ìˆ˜í–‰ë˜ëŠ”ê°€
- [ ] **EN**: Sensitive data is properly protected  
      **KO**: ë¯¼ê°í•œ ë°ì´í„°ê°€ ì ì ˆíˆ ë³´í˜¸ë˜ëŠ”ê°€
- [ ] **EN**: Authentication and authorization are correct  
      **KO**: ì¸ì¦ê³¼ ì¸ê°€ê°€ ì˜¬ë°”ë¥¸ê°€
- [ ] **EN**: No security vulnerabilities introduced  
      **KO**: ë³´ì•ˆ ì·¨ì•½ì ì´ ë„ì…ë˜ì§€ ì•Šì•˜ëŠ”ê°€

### ì„±ëŠ¥ / Performance
- [ ] **EN**: No unnecessary database queries (N+1 problem)  
      **KO**: ë¶ˆí•„ìš”í•œ ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ê°€ ì—†ëŠ”ê°€ (N+1 ë¬¸ì œ)
- [ ] **EN**: Appropriate use of caching  
      **KO**: ìºì‹±ì˜ ì ì ˆí•œ ì‚¬ìš©
- [ ] **EN**: Memory usage is optimized  
      **KO**: ë©”ëª¨ë¦¬ ì‚¬ìš©ì´ ìµœì í™”ë˜ì–´ ìˆëŠ”ê°€
- [ ] **EN**: No blocking calls in reactive paths  
      **KO**: ë¦¬ì•¡í‹°ë¸Œ ê²½ë¡œì—ì„œ ë¸”ë¡œí‚¹ í˜¸ì¶œì´ ì—†ëŠ”ê°€

### í…ŒìŠ¤íŠ¸ / Testing
- [ ] **EN**: Adequate test coverage (>80%)  
      **KO**: ì ì ˆí•œ í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ (>80%)
- [ ] **EN**: Tests are meaningful and not just for coverage  
      **KO**: í…ŒìŠ¤íŠ¸ê°€ ì˜ë¯¸ìˆê³  ë‹¨ìˆœíˆ ì»¤ë²„ë¦¬ì§€ë¥¼ ìœ„í•œ ê²ƒì´ ì•„ë‹Œê°€
- [ ] **EN**: Integration tests for critical paths  
      **KO**: ì¤‘ìš”í•œ ê²½ë¡œì— ëŒ€í•œ í†µí•© í…ŒìŠ¤íŠ¸
- [ ] **EN**: Tests are independent and repeatable  
      **KO**: í…ŒìŠ¤íŠ¸ê°€ ë…ë¦½ì ì´ê³  ë°˜ë³µ ê°€ëŠ¥í•œê°€
```

### 8.2 ì½”ë“œ ë¦¬ë·° ì˜ˆì‹œ / Code Review Examples

```kotlin
// âŒ Bad - Needs improvement
class UserController(private val userService: UserService) {
    
    // EN: Missing documentation and error handling
    // KO: ë¬¸ì„œí™” ë° ì˜¤ë¥˜ ì²˜ë¦¬ ëˆ„ë½
    @GetMapping("/users/{id}")
    fun getUser(@PathVariable id: String): UserDto {
        return userService.getUser(id)  // No error handling
    }
    
    // EN: Too many responsibilities in controller
    // KO: ì»¨íŠ¸ë¡¤ëŸ¬ì—ì„œ ë„ˆë¬´ ë§ì€ ì±…ì„
    @PostMapping("/users")
    fun createUser(@RequestBody request: CreateUserRequest): UserDto {
        // Validation logic in controller (should be in service)
        if (request.email.isBlank()) {
            throw IllegalArgumentException("Email required")
        }
        
        val user = userService.createUser(request)
        
        // Business logic in controller (should be in service)
        if (user.email.endsWith("@admin.com")) {
            // Grant admin role
        }
        
        return user
    }
}

// âœ… Good - After review improvements
/**
 * EN: RESTful controller for user management operations.
 * KO: ì‚¬ìš©ì ê´€ë¦¬ ì‘ì—…ì„ ìœ„í•œ RESTful ì»¨íŠ¸ë¡¤ëŸ¬.
 */
@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "Users")
class UserController(
    private val userService: UserService
) {
    
    /**
     * EN: Retrieves user information by user ID.
     * KO: ì‚¬ìš©ì IDë¡œ ì‚¬ìš©ì ì •ë³´ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
     */
    @GetMapping("/{userId}")
    fun getUser(@PathVariable userId: String): ResponseEntity<UserDto> {
        return try {
            val user = userService.getUser(userId)
            ResponseEntity.ok(user)
        } catch (e: ResourceNotFoundException) {
            throw e  // Let global exception handler manage this
        }
    }
    
    /**
     * EN: Creates a new user account with proper validation.
     * KO: ì ì ˆí•œ ê²€ì¦ê³¼ í•¨ê»˜ ìƒˆë¡œìš´ ì‚¬ìš©ì ê³„ì •ì„ ìƒì„±í•©ë‹ˆë‹¤.
     */
    @PostMapping
    fun createUser(
        @Valid @RequestBody request: CreateUserRequest
    ): ResponseEntity<UserDto> {
        val user = userService.createUserWithRoleAssignment(request)
        return ResponseEntity.status(HttpStatus.CREATED).body(user)
    }
}
```

## 9. í’ˆì§ˆ ê²Œì´íŠ¸ ë° ìë™í™” ê²€ì‚¬ / Quality Gates & Automated Checks

### 9.1 CI/CD íŒŒì´í”„ë¼ì¸ í’ˆì§ˆ ê²Œì´íŠ¸ / CI/CD Pipeline Quality Gates

```yaml
# .github/workflows/code-quality.yml
name: Code Quality Checks

on:
  pull_request:
    branches: [ main, develop ]
  push:
    branches: [ main, develop ]

jobs:
  quality-gates:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Setup Java
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
        
    # EN: Code formatting check with ktlint
    # KO: ktlintë¥¼ ì‚¬ìš©í•œ ì½”ë“œ í¬ë§·íŒ… ê²€ì‚¬
    - name: Ktlint Check
      run: ./gradlew ktlintCheck
      
    # EN: Static code analysis with detekt  
    # KO: detektë¥¼ ì‚¬ìš©í•œ ì •ì  ì½”ë“œ ë¶„ì„
    - name: Detekt Analysis
      run: ./gradlew detekt
      
    # EN: Run unit and integration tests
    # KO: ë‹¨ìœ„ ë° í†µí•© í…ŒìŠ¤íŠ¸ ì‹¤í–‰
    - name: Run Tests
      run: ./gradlew test integrationTest
      
    # EN: Generate test coverage report
    # KO: í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ ë¦¬í¬íŠ¸ ìƒì„±
    - name: Generate Coverage Report
      run: ./gradlew jacocoTestReport
      
    # EN: Quality gate - fail if coverage below threshold
    # KO: í’ˆì§ˆ ê²Œì´íŠ¸ - ì»¤ë²„ë¦¬ì§€ê°€ ì„ê³„ê°’ ì´í•˜ì¼ ê²½ìš° ì‹¤íŒ¨
    - name: Coverage Quality Gate
      run: ./gradlew jacocoCoverageVerification
```

### 9.2 Gradle í’ˆì§ˆ ê²€ì‚¬ ì„¤ì • / Gradle Quality Check Configuration

```kotlin
// server/build.gradle.kts
plugins {
    id("jacoco")
    id("org.jlleitschuh.gradle.ktlint")
    id("io.gitlab.arturbosch.detekt")
}

// EN: Ktlint configuration for Google Style Guide
// KO: Google ìŠ¤íƒ€ì¼ ê°€ì´ë“œë¥¼ ìœ„í•œ ktlint ì„¤ì •
ktlint {
    version.set("0.50.0")
    debug.set(false)
    verbose.set(true)
    android.set(false)
    outputToConsole.set(true)
    configurationFile.set(file("config/ktlint.yml"))
    
    filter {
        exclude("**/generated/**")
        include("**/kotlin/**")
    }
}

// EN: Detekt configuration for static analysis
// KO: ì •ì  ë¶„ì„ì„ ìœ„í•œ detekt ì„¤ì •  
detekt {
    toolVersion = "1.23.8"
    config.setFrom(file("config/detekt.yml"))
    baseline = file("config/baseline.xml")
    
    reports {
        html.required.set(true)
        xml.required.set(true)
        txt.required.set(false)
    }
}

// EN: Jacoco configuration for test coverage
// KO: í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ë¥¼ ìœ„í•œ jacoco ì„¤ì •
jacoco {
    toolVersion = "0.8.8"
}

tasks.jacocoTestReport {
    dependsOn(tasks.test)
    
    reports {
        xml.required.set(true)
        html.required.set(true)
        csv.required.set(false)
    }
    
    finalizedBy(tasks.jacocoCoverageVerification)
}

tasks.jacocoCoverageVerification {
    violationRules {
        rule {
            limit {
                // EN: Minimum 80% line coverage required
                // KO: ìµœì†Œ 80% ë¼ì¸ ì»¤ë²„ë¦¬ì§€ í•„ìˆ˜
                counter = "LINE"
                value = "COVEREDRATIO"
                minimum = "0.80".toBigDecimal()
            }
            
            limit {
                // EN: Minimum 75% branch coverage required  
                // KO: ìµœì†Œ 75% ë¸Œëœì¹˜ ì»¤ë²„ë¦¬ì§€ í•„ìˆ˜
                counter = "BRANCH"
                value = "COVEREDRATIO"
                minimum = "0.75".toBigDecimal()
            }
        }
        
        rule {
            element = "CLASS"
            excludes = listOf(
                "*.Application*",
                "*.config.*",
                "*.dto.*",
                "*Test*"
            )
            
            limit {
                counter = "LINE"
                value = "COVEREDRATIO"
                minimum = "0.85".toBigDecimal()
            }
        }
    }
}
```

### 9.3 SonarQube í†µí•© / SonarQube Integration

```kotlin
// EN: SonarQube configuration for comprehensive code analysis
// KO: í¬ê´„ì ì¸ ì½”ë“œ ë¶„ì„ì„ ìœ„í•œ SonarQube ì„¤ì •

plugins {
    id("org.sonarqube") version "3.5.0"
}

sonarqube {
    properties {
        // EN: Project configuration
        // KO: í”„ë¡œì íŠ¸ ì„¤ì •
        property("sonar.projectName", "Girls Band Tabi")
        property("sonar.projectKey", "org.pyrimidines:girlsbandtabi")
        property("sonar.projectVersion", project.version.toString())
        
        // EN: Source and test directories
        // KO: ì†ŒìŠ¤ ë° í…ŒìŠ¤íŠ¸ ë””ë ‰í„°ë¦¬
        property("sonar.sources", "src/main/kotlin")
        property("sonar.tests", "src/test/kotlin,src/integrationTest/kotlin")
        
        // EN: Coverage reports
        // KO: ì»¤ë²„ë¦¬ì§€ ë¦¬í¬íŠ¸
        property("sonar.coverage.jacoco.xmlReportPaths", 
                "${buildDir}/reports/jacoco/test/jacocoTestReport.xml")
        
        // EN: Quality gates - must meet these criteria
        // KO: í’ˆì§ˆ ê²Œì´íŠ¸ - ë‹¤ìŒ ê¸°ì¤€ì„ ì¶©ì¡±í•´ì•¼ í•¨
        property("sonar.qualitygate.wait", "true")
        
        // EN: Code quality thresholds
        // KO: ì½”ë“œ í’ˆì§ˆ ì„ê³„ê°’
        property("sonar.coverage.exclusions", "**/dto/**,**/config/**,**/Application.kt")
        property("sonar.cpd.exclusions", "**/dto/**,**/entity/**")
        
        // EN: Security hotspot analysis
        // KO: ë³´ì•ˆ í•«ìŠ¤íŒŸ ë¶„ì„
        property("sonar.security.hotspots.inheritFromParent", "true")
        
        // EN: Performance analysis
        // KO: ì„±ëŠ¥ ë¶„ì„  
        property("sonar.kotlin.performance.measure", "true")
    }
}

// EN: Quality gate task that fails build if quality criteria not met
// KO: í’ˆì§ˆ ê¸°ì¤€ì„ ì¶©ì¡±í•˜ì§€ ì•Šìœ¼ë©´ ë¹Œë“œë¥¼ ì‹¤íŒ¨ì‹œí‚¤ëŠ” í’ˆì§ˆ ê²Œì´íŠ¸ ì‘ì—…
tasks.register("qualityGate") {
    dependsOn("test", "detekt", "ktlintCheck", "jacocoCoverageVerification")
    
    doLast {
        println("âœ… All quality gates passed!")
        println("ğŸ“Š Code coverage: Check reports/jacoco/test/html/index.html")  
        println("ğŸ” Static analysis: Check reports/detekt/detekt.html")
        println("ğŸ¯ Formatting: ktlint checks passed")
    }
}
```

## 10. ë¦¬íŒ©í„°ë§ ê°€ì´ë“œë¼ì¸ ë° ê¸°ìˆ  ë¶€ì±„ ê´€ë¦¬ / Refactoring Guidelines & Technical Debt Management

### 10.1 ë¦¬íŒ©í„°ë§ ì›ì¹™ / Refactoring Principles

```kotlin
/**
 * EN: Refactoring guidelines following Martin Fowler's principles
 * KO: Martin Fowlerì˜ ì›ì¹™ì— ë”°ë¥¸ ë¦¬íŒ©í„°ë§ ê°€ì´ë“œë¼ì¸
 */

// âŒ Before refactoring - Code smell: Large class with multiple responsibilities
class UserManagementService(
    private val userRepository: UserRepository,
    private val emailService: EmailService,
    private val smsService: SmsService,
    private val auditLogService: AuditLogService,
    private val passwordEncoder: PasswordEncoder
) {
    // EN: Too many methods handling different concerns
    // KO: ì„œë¡œ ë‹¤ë¥¸ ê´€ì‹¬ì‚¬ë¥¼ ì²˜ë¦¬í•˜ëŠ” ë©”ì†Œë“œê°€ ë„ˆë¬´ ë§ìŒ
    
    fun createUser(request: CreateUserRequest): UserDto { /* ... */ }
    fun updateUser(userId: String, request: UpdateUserRequest): UserDto { /* ... */ }
    fun deleteUser(userId: String) { /* ... */ }
    fun sendWelcomeEmail(userId: String) { /* ... */ }
    fun sendPasswordResetSms(userId: String) { /* ... */ }
    fun logUserAction(userId: String, action: String) { /* ... */ }
    fun validatePassword(password: String): Boolean { /* ... */ }
    fun encryptUserData(data: String): String { /* ... */ }
}

// âœ… After refactoring - Separated concerns using SRP
/**
 * EN: User data management operations only
 * KO: ì‚¬ìš©ì ë°ì´í„° ê´€ë¦¬ ì‘ì—…ë§Œ
 */
@Service
class UserService(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder
) {
    fun createUser(request: CreateUserRequest): UserDto {
        val user = UserEntity.fromRequest(request, passwordEncoder)
        return userRepository.save(user).toDto()
    }
    
    fun updateUser(userId: String, request: UpdateUserRequest): UserDto {
        val user = userRepository.findByIdOrThrow(userId)
        user.updateFromRequest(request)
        return userRepository.save(user).toDto()
    }
    
    fun deleteUser(userId: String) {
        userRepository.deleteById(userId)
    }
}

/**
 * EN: Notification operations separated
 * KO: ì•Œë¦¼ ì‘ì—… ë¶„ë¦¬
 */
@Service  
class UserNotificationService(
    private val emailService: EmailService,
    private val smsService: SmsService
) {
    fun sendWelcomeNotification(user: UserDto) {
        emailService.sendWelcomeEmail(user.email, user.username)
    }
    
    fun sendPasswordResetNotification(user: UserDto) {
        smsService.sendPasswordResetCode(user.phoneNumber, generateResetCode())
    }
}

/**
 * EN: User-related validation operations
 * KO: ì‚¬ìš©ì ê´€ë ¨ ê²€ì¦ ì‘ì—…
 */
@Component
class UserValidator {
    fun validatePassword(password: String): ValidationResult {
        // Validation logic
    }
    
    fun validateUserRequest(request: CreateUserRequest): ValidationResult {
        // Request validation logic
    }
}
```

### 10.2 ê¸°ìˆ  ë¶€ì±„ ì‹ë³„ ë° ê´€ë¦¬ / Technical Debt Identification & Management

```kotlin
/**
 * EN: Technical debt documentation and tracking system
 * KO: ê¸°ìˆ  ë¶€ì±„ ë¬¸ì„œí™” ë° ì¶”ì  ì‹œìŠ¤í…œ
 */

// TODO ë§ˆì»¤ë¥¼ ì‚¬ìš©í•œ ê¸°ìˆ  ë¶€ì±„ ì¶”ì  / Technical debt tracking using TODO markers
class ProjectService {
    
    fun getProjectStatistics(projectId: String): ProjectStatsDto {
        // TODO-DEBT: [PERFORMANCE] O(n) query for each project stat - Priority: HIGH
        // EN: Current implementation queries database for each statistic separately
        // KO: í˜„ì¬ êµ¬í˜„ì€ ê° í†µê³„ì— ëŒ€í•´ ë³„ë„ë¡œ ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ì¿¼ë¦¬í•¨
        // Refactor to: Single query with aggregations
        // Timeline: Sprint 23.4
        // Impact: High - causes N+1 problem with many projects
        val userCount = userRepository.countByProjectId(projectId)
        val activeUserCount = userRepository.countByProjectIdAndIsActive(projectId, true)
        val eventCount = eventRepository.countByProjectId(projectId)
        
        return ProjectStatsDto(userCount, activeUserCount, eventCount)
    }
    
    // FIXME-DEBT: [SECURITY] Missing input validation - Priority: CRITICAL
    // EN: No input sanitization before database query
    // KO: ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ì „ ì…ë ¥ ì •í™” ì—†ìŒ
    // Timeline: Immediate
    fun searchProjects(query: String): List<ProjectDto> {
        return projectRepository.findByNameContaining(query).map { it.toDto() }
    }
}

// EN: Technical debt registry in dedicated file
// KO: ì „ìš© íŒŒì¼ì˜ ê¸°ìˆ  ë¶€ì±„ ë“±ë¡ë¶€
```

```markdown
## ê¸°ìˆ  ë¶€ì±„ ë“±ë¡ë¶€ / Technical Debt Registry

### ë†’ì€ ìš°ì„ ìˆœìœ„ / High Priority

| ID | ì»´í¬ë„ŒíŠ¸ | ì„¤ëª… | ì˜í–¥ë„ | ì˜ˆìƒ ì‘ì—…ëŸ‰ | ë§ˆê°ì¼ |
|----|---------|------|--------|-------------|--------|
| TD-001 | ProjectService.getProjectStatistics | N+1 ì¿¼ë¦¬ ë¬¸ì œë¡œ ì„±ëŠ¥ ì €í•˜ | HIGH | 2 story points | Sprint 23.4 |
| TD-002 | AuthenticationFilter | ë ˆê±°ì‹œ ì„¸ì…˜ ê´€ë¦¬ ë¡œì§ | MEDIUM | 5 story points | Sprint 23.5 |
| TD-003 | FileUploadController | ì„ì‹œ íŒŒì¼ ì •ë¦¬ ë¡œì§ ëˆ„ë½ | HIGH | 1 story point | Sprint 23.4 |

### ì§„í–‰ ì¤‘ / In Progress

| ID | ë‹´ë‹¹ì | ì‹œì‘ì¼ | ì˜ˆìƒ ì™„ë£Œì¼ | ìƒíƒœ |
|----|--------|--------|-------------|------|
| TD-001 | ê¹€ê°œë°œ | 2025-11-10 | 2025-11-15 | êµ¬í˜„ ì¤‘ |

### ì™„ë£Œë¨ / Completed

| ID | ì™„ë£Œì¼ | í•´ê²° ë°©ë²• | ì„±ê³¼ |
|----|--------|-----------|------|
| TD-004 | 2025-11-01 | Repository query optimization | ì‘ë‹µì‹œê°„ 50% ê°œì„  |
```

### 10.3 ì•ˆì „í•œ ë¦¬íŒ©í„°ë§ íŒ¨í„´ / Safe Refactoring Patterns

```kotlin
/**
 * EN: Step-by-step refactoring approach with backwards compatibility
 * KO: í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ ì§€í•˜ëŠ” ë‹¨ê³„ë³„ ë¦¬íŒ©í„°ë§ ì ‘ê·¼ë²•
 */

// Step 1: EN: Create new interface alongside old implementation
//        KO: ê¸°ì¡´ êµ¬í˜„ê³¼ í•¨ê»˜ ìƒˆ ì¸í„°í˜ì´ìŠ¤ ìƒì„±
interface UserServiceV2 {
    fun createUserWithValidation(request: CreateUserRequest): UserDto
    fun updateUserSafely(userId: String, request: UpdateUserRequest): UserDto
}

// Step 2: EN: Implement new interface with improved logic
//        KO: ê°œì„ ëœ ë¡œì§ìœ¼ë¡œ ìƒˆ ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
@Service("userServiceV2")
class ImprovedUserService(
    private val userRepository: UserRepository,
    private val validator: UserValidator,
    private val auditService: AuditLogService
) : UserServiceV2 {
    
    override fun createUserWithValidation(request: CreateUserRequest): UserDto {
        // EN: Enhanced validation and error handling
        // KO: í–¥ìƒëœ ê²€ì¦ ë° ì˜¤ë¥˜ ì²˜ë¦¬
        val validationResult = validator.validateCreateRequest(request)
        if (!validationResult.isValid) {
            throw ValidationException("Invalid request", validationResult.errors)
        }
        
        return try {
            val user = UserEntity.fromRequest(request)
            val savedUser = userRepository.save(user)
            auditService.logUserCreated(savedUser.id)
            savedUser.toDto()
        } catch (e: Exception) {
            auditService.logUserCreationFailed(request.username, e)
            throw BusinessLogicException("User creation failed", "USER_CREATION_ERROR", e)
        }
    }
}

// Step 3: EN: Create facade to gradually migrate consumers
//        KO: ì†Œë¹„ìë¥¼ ì ì§„ì ìœ¼ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜í•˜ê¸° ìœ„í•œ facade ìƒì„±
@Service
class UserServiceFacade(
    @Qualifier("userService") private val legacyService: UserService,
    @Qualifier("userServiceV2") private val improvedService: ImprovedUserService,
    @Value("\${app.features.use-improved-user-service:false}") 
    private val useImprovedService: Boolean
) {
    
    fun createUser(request: CreateUserRequest): UserDto {
        return if (useImprovedService) {
            // EN: Use new implementation when feature flag is enabled
            // KO: ê¸°ëŠ¥ í”Œë˜ê·¸ê°€ í™œì„±í™”ëœ ê²½ìš° ìƒˆ êµ¬í˜„ ì‚¬ìš©
            improvedService.createUserWithValidation(request)
        } else {
            // EN: Fall back to legacy implementation
            // KO: ë ˆê±°ì‹œ êµ¬í˜„ìœ¼ë¡œ í´ë°±
            legacyService.createUser(request)
        }
    }
}

// Step 4: EN: Deprecate old methods with migration guidance
//        KO: ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ì´ë“œì™€ í•¨ê»˜ ê¸°ì¡´ ë©”ì†Œë“œ deprecated ì²˜ë¦¬
@Service
@Deprecated("Use UserServiceV2 instead", ReplaceWith("ImprovedUserService"))
class UserService {
    
    @Deprecated(
        message = "Use UserServiceFacade.createUser() instead",
        replaceWith = ReplaceWith("userServiceFacade.createUser(request)")
    )
    fun createUser(request: CreateUserRequest): UserDto {
        // Legacy implementation with warning log
        logger.warn("Using deprecated UserService.createUser - migrate to UserServiceV2")
        // ... legacy logic
    }
}
```

### 10.4 ì½”ë“œ í’ˆì§ˆ ë©”íŠ¸ë¦­ ë° ëª¨ë‹ˆí„°ë§ / Code Quality Metrics & Monitoring

```kotlin
/**
 * EN: Automated code quality monitoring and alerts
 * KO: ìë™í™”ëœ ì½”ë“œ í’ˆì§ˆ ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼
 */

// gradle ì„¤ì •ì—ì„œ í’ˆì§ˆ ë©”íŠ¸ë¦­ ì„ê³„ê°’ ì •ì˜ / Quality metric thresholds in gradle config
tasks.register("codeQualityReport") {
    dependsOn("test", "jacocoTestReport", "detekt")
    
    doLast {
        val coverageFile = file("${buildDir}/reports/jacoco/test/jacocoTestReport.xml")
        val detektFile = file("${buildDir}/reports/detekt/detekt.xml")
        
        // EN: Parse coverage metrics
        // KO: ì»¤ë²„ë¦¬ì§€ ë©”íŠ¸ë¦­ íŒŒì‹±
        val coverage = parseCoverageReport(coverageFile)
        
        // EN: Parse static analysis results
        // KO: ì •ì  ë¶„ì„ ê²°ê³¼ íŒŒì‹±
        val codeSmells = parseDetektReport(detektFile)
        
        // EN: Generate quality dashboard
        // KO: í’ˆì§ˆ ëŒ€ì‹œë³´ë“œ ìƒì„±
        generateQualityDashboard(coverage, codeSmells)
        
        // EN: Alert if quality gates fail
        // KO: í’ˆì§ˆ ê²Œì´íŠ¸ ì‹¤íŒ¨ ì‹œ ì•Œë¦¼
        if (coverage.linePercentage < 80.0) {
            throw GradleException("âŒ Coverage below threshold: ${coverage.linePercentage}%")
        }
        
        if (codeSmells.criticalIssues > 0) {
            throw GradleException("âŒ Critical code smells detected: ${codeSmells.criticalIssues}")
        }
        
        println("""
            âœ… Code Quality Report
            ğŸ“Š Line Coverage: ${coverage.linePercentage}%
            ğŸ¯ Branch Coverage: ${coverage.branchPercentage}%
            ğŸ” Code Smells: ${codeSmells.totalIssues}
            âš¡ Complexity: ${codeSmells.averageComplexity}
        """.trimIndent())
    }
}

data class CoverageMetrics(
    val linePercentage: Double,
    val branchPercentage: Double,
    val missedLines: Int
)

data class StaticAnalysisMetrics(
    val totalIssues: Int,
    val criticalIssues: Int,
    val averageComplexity: Double,
    val duplicatedLines: Int
)
```

## í’ˆì§ˆ ë©”íŠ¸ë¦­ ëª©í‘œ / Quality Metrics Targets

### ì½”ë“œ ì»¤ë²„ë¦¬ì§€ ëª©í‘œ / Code Coverage Targets

- **ì „ì²´ ë¼ì¸ ì»¤ë²„ë¦¬ì§€ / Overall Line Coverage**: â‰¥ 80%
- **ì„œë¹„ìŠ¤ ë ˆì´ì–´ / Service Layer**: â‰¥ 90%
- **ì»¨íŠ¸ë¡¤ëŸ¬ ë ˆì´ì–´ / Controller Layer**: â‰¥ 85%
- **ë¸Œëœì¹˜ ì»¤ë²„ë¦¬ì§€ / Branch Coverage**: â‰¥ 75%

### ì •ì  ë¶„ì„ ëª©í‘œ / Static Analysis Targets

- **ìˆœí™˜ ë³µì¡ë„ / Cyclomatic Complexity**: â‰¤ 10 per method
- **í´ë˜ìŠ¤ í¬ê¸° / Class Size**: â‰¤ 300 lines
- **ë©”ì†Œë“œ í¬ê¸° / Method Size**: â‰¤ 50 lines
- **ì¤‘ìš” ì½”ë“œ ìŠ¤ë©œ / Critical Code Smells**: 0

### ì„±ëŠ¥ ëª©í‘œ / Performance Targets

- **ì‘ë‹µ ì‹œê°„ / Response Time**: 95% < 200ms
- **ì²˜ë¦¬ëŸ‰ / Throughput**: > 1000 requests/second
- **ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ / Memory Usage**: < 512MB heap

## ì‹œí–‰ ë©”ì»¤ë‹ˆì¦˜ / Enforcement Mechanisms

### Git Hooks

```bash
#!/bin/sh
# .git/hooks/pre-commit
# EN: Pre-commit hook to enforce code quality
# KO: ì½”ë“œ í’ˆì§ˆ ê°•ì œë¥¼ ìœ„í•œ pre-commit hook

echo "ğŸ” Running pre-commit quality checks..."

# Run ktlint formatting
./gradlew ktlintFormat

# Run static analysis
./gradlew detekt
if [ $? -ne 0 ]; then
    echo "âŒ Detekt analysis failed. Please fix issues before committing."
    exit 1
fi

# Run tests
./gradlew test
if [ $? -ne 0 ]; then
    echo "âŒ Tests failed. Please fix failing tests before committing."
    exit 1
fi

echo "âœ… Pre-commit checks passed!"
```

### IDE ì„¤ì • / IDE Configuration

```xml
<!-- .idea/codeStyles/Project.xml -->
<component name="ProjectCodeStyleConfiguration">
  <code_scheme name="Project" version="173">
    <option name="LINE_SEPARATOR" value="&#10;" />
    <option name="RIGHT_MARGIN" value="100" />
    <JetCodeStyleSettings>
      <option name="PACKAGES_TO_USE_STAR_IMPORTS">
        <value />
      </option>
    </JetCodeStyleSettings>
    <codeStyleSettings language="kotlin">
      <option name="RIGHT_MARGIN" value="100" />
      <option name="KEEP_LINE_BREAKS" value="true" />
      <option name="KEEP_FIRST_COLUMN_COMMENT" value="true" />
    </codeStyleSettings>
  </code_scheme>
</component>
```

---

## ë¬¸ì„œ ì´ë ¥ / Document History

| ë²„ì „ | ë‚ ì§œ | ë³€ê²½ì‚¬í•­ | ì‘ì„±ì |
|------|------|----------|--------|
| 1.0.0 | 2025-11-13 | **EN**: Initial comprehensive coding standards guide<br>**KO**: ì´ˆê¸° ì¢…í•© ì½”ë”© í‘œì¤€ ê°€ì´ë“œ | Development Team |

---

**EN**: This document should be reviewed quarterly and updated as project requirements evolve.  
**KO**: ì´ ë¬¸ì„œëŠ” ë¶„ê¸°ë³„ë¡œ ê²€í† í•˜ê³  í”„ë¡œì íŠ¸ ìš”êµ¬ì‚¬í•­ ë³€í™”ì— ë”°ë¼ ì—…ë°ì´íŠ¸í•´ì•¼ í•©ë‹ˆë‹¤.

**ì°¸ê³  ìë£Œ / References:**
- [Google Kotlin Style Guide](https://developer.android.com/kotlin/style-guide)
- [Spring Boot Best Practices](https://docs.spring.io/spring-boot/docs/current/reference/html/)
- [Clean Code by Robert C. Martin](https://www.oreilly.com/library/view/clean-code-a/9780136083238/)
- [Refactoring: Improving the Design of Existing Code by Martin Fowler](https://refactoring.com/)